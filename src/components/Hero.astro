---

---

<section
    id="hero"
    class="relative w-full h-screen flex flex-col items-center justify-center overflow-hidden"
>
    <!-- Background Elements (optional, can be kept for hero specific styling or removed) -->
    <div class="absolute inset-0 z-0 bg-void/10">
        <!-- Reduced opacity to see canvas if needed, or remove bg-void to be transparent -->
        <div
            class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[600px] h-[600px] bg-primary/20 blur-[120px] rounded-full animate-pulse-slow"
        >
        </div>
    </div>

    <!-- 3D Scene Container (Fixed Background) -->
    <div
        id="canvas-container"
        class="fixed inset-0 z-0 w-full h-full pointer-events-none"
    >
    </div>

    <!-- Content -->
    <div
        class="relative z-20 text-center px-4 max-w-4xl mx-auto flex flex-col items-center gap-6"
    >
        <h1
            class="text-6xl md:text-8xl font-bold tracking-tighter leading-tight opacity-0 translate-y-10 hero-text"
        >
            <span
                class="text-transparent bg-clip-text bg-gradient-to-br from-white to-white/50"
                >Stickers</span
            >
            <br />
            <span
                class="text-transparent bg-clip-text bg-gradient-to-r from-primary to-secondary"
                >que respiran</span
            >
        </h1>

        <p
            class="text-xl md:text-2xl text-muted max-w-2xl opacity-0 translate-y-10 hero-text"
        >
            Tecnología fotocatalítica que transforma el aire urbano. <br />
            <span class="text-primary font-semibold">Estilo que purifica.</span>
        </p>

        <div class="flex gap-4 mt-4 opacity-0 translate-y-10 hero-text">
            <a
                href="#products"
                class="px-8 py-4 rounded-full bg-white text-primary font-bold text-lg hover:bg-gray-100 transform hover:scale-105 transition-all shadow-xl shadow-white/10"
            >
                Ver Colección
            </a>
            <a
                href="#technology"
                class="px-8 py-4 rounded-full border border-white/20 hover:bg-white/5 backdrop-blur-md text-white font-medium text-lg transition-all"
            >
                La Tecnología
            </a>
        </div>
    </div>

    <!-- Scroll Indicator -->
    <div
        class="absolute bottom-10 left-1/2 -translate-x-1/2 animate-bounce z-20 opacity-0 hero-text"
    >
        <svg
            class="w-6 h-6 text-muted"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
        >
            <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 14l-7 7m0 0l-7-7m7 7V3"></path>
        </svg>
    </div>
</section>

<script>
    import * as THREE from "three";
    import gsap from "gsap";
    import { ScrollTrigger } from "gsap/ScrollTrigger";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js"; // Added .js extension back

    gsap.registerPlugin(ScrollTrigger);

    // Animation Intro
    gsap.to(".hero-text", {
        y: 0,
        opacity: 1,
        duration: 1.2,
        stagger: 0.2,
        ease: "power3.out",
        delay: 0.5,
    });

    // 3D Scene Setup
    const init3D = () => {
        const container = document.getElementById("canvas-container");
        if (!container) return;

        const scene = new THREE.Scene();

        // Camera
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000,
        );
        camera.position.z = 5;

        // Renderer
        const renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Perf optimization
        container.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        const spotLight = new THREE.SpotLight(0x7e22ce, 5); // Primary color tint boosted
        spotLight.position.set(-5, 5, 20); // Moved to be more frontal/top-left
        scene.add(spotLight);

        // Rim Light (Back) - Creates a nice outline/halo
        const rimLight = new THREE.SpotLight(0x4f46e5, 5); // Secondary color
        rimLight.position.set(0, 5, -10);
        rimLight.lookAt(0, 0, 0);
        scene.add(rimLight);

        // Fill Light (Side-Front) - Softens shadows
        // Boosted intensity for better frontal visibility
        const fillLight = new THREE.DirectionalLight(0xffffff, 4);
        fillLight.position.set(5, 0, 5);
        scene.add(fillLight);

        // Load GLB Model
        let model: THREE.Group | null = null;
        const loader = new GLTFLoader();

        loader.load(
            "/assets/models/sticker.glb",
            (gltf: any) => {
                const sceneModel = gltf.scene;

                // Create a Pivot Group to handle rotation cleanly
                const pivotGroup = new THREE.Group();
                scene.add(pivotGroup);
                pivotGroup.add(sceneModel);

                model = pivotGroup; // Keep reference to pivot for animation loop

                // Center the model relative to the pivot
                const box = new THREE.Box3().setFromObject(sceneModel);
                const center = box.getCenter(new THREE.Vector3());
                sceneModel.position.sub(center);

                // Internal Orientation: Fix the "martian" look
                // Keep the model facing front (Camera)
                sceneModel.rotation.x = Math.PI / 2;
                sceneModel.rotation.y = THREE.MathUtils.degToRad(-120);

                // Initial animation pop
                gsap.from(sceneModel.scale, {
                    x: 0,
                    y: 0,
                    z: 0,
                    duration: 1.5,
                    ease: "elastic.out(1, 0.5)",
                });

                // Scroll Trigger: Scene Y Rotation (Spin horizontally)

                // Scroll Trigger: Scene Y Rotation (Spin horizontally)
                gsap.to(pivotGroup.rotation, {
                    scrollTrigger: {
                        trigger: "body", // Use body to span the whole page scroll
                        start: "top top",
                        end: "bottom bottom",
                        scrub: 1,
                    },
                    y: Math.PI * 2, // Full 360 spin around global Y axis
                    ease: "none",
                });
            },
            undefined,
            (error: any) => {
                console.error(
                    "An error happened loading the GLB model:",
                    error,
                );
            },
        );

        // --- SMOG PARTICLE SYSTEM ---
        const particleCount = 200;
        const particlesGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleInitialPositions = new Float32Array(particleCount * 3);
        const particleSpeeds = new Float32Array(particleCount);

        // Helper: Generate procedural smog texture
        const getSmogTexture = () => {
            const canvas = document.createElement("canvas");
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext("2d");
            if (context) {
                const gradient = context.createRadialGradient(
                    16,
                    16,
                    0,
                    16,
                    16,
                    16,
                );
                gradient.addColorStop(0, "rgba(100, 100, 100, 0.8)"); // Dark grey center
                gradient.addColorStop(1, "rgba(0, 0, 0, 0)"); // Transparent edge
                context.fillStyle = gradient;
                context.fillRect(0, 0, 32, 32);
            }
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        };

        // Initialize particles
        for (let i = 0; i < particleCount; i++) {
            // Random position in a sphere around the center (radius 8 to 15)
            const r = 8 + Math.random() * 7;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            particlePositions[i * 3] = x;
            particlePositions[i * 3 + 1] = y;
            particlePositions[i * 3 + 2] = z;

            particleInitialPositions[i * 3] = x;
            particleInitialPositions[i * 3 + 1] = y;
            particleInitialPositions[i * 3 + 2] = z;

            particleSpeeds[i] = 0.5 + Math.random() * 0.5; // Random varied speed
        }

        particlesGeometry.setAttribute(
            "position",
            new THREE.BufferAttribute(particlePositions, 3),
        );

        const particlesMaterial = new THREE.PointsMaterial({
            color: 0x888888,
            size: 0.8,
            map: getSmogTexture(),
            transparent: true,
            opacity: 0.8,
            depthWrite: false, // Avoid z-fighting
            blending: THREE.NormalBlending,
        });

        const particleSystem = new THREE.Points(
            particlesGeometry,
            particlesMaterial,
        );
        scene.add(particleSystem);

        // Scroll State for particles
        const scrollState = { progress: 0 };

        gsap.to(scrollState, {
            scrollTrigger: {
                trigger: "body",
                start: "top top",
                end: "bottom bottom",
                scrub: 1, // Smooth interaction
            },
            progress: 1,
            ease: "none",
        });

        // Mouse Interaction
        let mouseX = 0;
        let mouseY = 0;

        window.addEventListener("mousemove", (e) => {
            mouseX = (e.clientX - window.innerWidth / 2) * 0.0005;
            mouseY = (e.clientY - window.innerHeight / 2) * 0.0005;
        });

        // Animation Loop
        const animate = () => {
            requestAnimationFrame(animate);

            // Update Particles
            const positions = particlesGeometry.attributes.position.array;

            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 1. Calculate target position (moving towards center)
                // As progress goes 0 -> 1, convergence factor goes 1 -> 0
                // We want them to get sucked effectively.
                const convergence = Math.max(
                    0,
                    1 - scrollState.progress * 1.5 * particleSpeeds[i],
                );

                // Add some chaotic Float noise
                const time = Date.now() * 0.001;
                const noiseX = Math.sin(time + i) * 0.1;
                const noiseY = Math.cos(time + i * 0.5) * 0.1;

                // New Position = Initial * convergence + noise
                positions[ix] =
                    particleInitialPositions[ix] * convergence + noiseX;
                positions[iy] =
                    particleInitialPositions[iy] * convergence + noiseY;
                positions[iz] = particleInitialPositions[iz] * convergence;
            }

            particlesGeometry.attributes.position.needsUpdate = true;

            // Opacity fade based on overall progress (or average distance)
            // Simpler: fade out material opacity as they get sucked in
            // Or keep opacity high until they disappear?
            // Let's fade them out as they get very close (progress > 0.8)
            if (scrollState.progress > 0.1) {
                particlesMaterial.opacity = THREE.MathUtils.lerp(
                    0.8,
                    0,
                    scrollState.progress,
                );
            } else {
                particlesMaterial.opacity = 0.8;
            }

            if (model) {
                // Stop idle rotation
                // model.rotation.x += 0.001;
                // model.rotation.y += 0.002;
                // Mouse tilt (subtle)
                // model.rotation.x = (Math.PI / 2) + (mouseY * 0.1);
                // model.rotation.y = mouseX * 0.1;
                // Just keep it steady for now based on user request "que se quede fijo"
            }

            renderer.render(scene, camera);
        };

        animate();

        // Resize Handler
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    };

    // Run 3D only on client
    init3D();
</script>
